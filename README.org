#+TITLE: Fundamental Software Architecture
#+AUTHOR: Marvin Dostal
#+LANGUAGE: en_us

* Goal

This document aims to communicate the fundamentals of software architecture in a succinct but easy to understand way.

* (Optional) Introduction

If one is already very experienced with creating software, this document might seem unnecessary or obvious.
However, I do think it is important to try to express what I have learned over the years.
I do not claim that this is the one valid way to look at software architecture.
However, I do hope it is a useful view.

The topic of software architecture often-times feels impossible to put into words:
making it hard to write down the fundamentals.
Long books exist that write about this topic.
However, they are trying to cover the topic to extensive, e.g., they are trying to go over every edge cases.
It is too difficult to keep all the information of those resources in the active memory.

This document will try to describe only very few concepts that IMHO are already sufficient to understand how "good" software is usually structured.
"good" in the context of this document is primarily concerned with /understandability/ and /maintainability/.

** Why "performance" is omitted

While performance is an important part of "good" software, software is usually already good enough when keeping things simple.
It can be true that a chosen architecture, which follows the details described here, can have horrible performance,
however, in my experience this can usually be solved by looking at the specific locations that slow everything down and optimizing them.

One principle to keep in mind for good performance is to process data in batches. This is beneficial for:
- sharing computation results
  - as opposed to calculating the same thing over and over for a slightly different context
- hardware access can be combined
  - as opposed to doing every hardware access sequentially
- if the data to be processed and the result memory are coherent memory blocks, CPU caches work efficient
  - as opposed to data and results being scattered all over the system requiring the CPU to stop and wait for fetching the data into the cache
- parallelization can be introduced more easily to work on multiple elements of the batch in parallel
  - as opposed to doing everything sequentially
- etc.

Sometimes these performance improvements introduce additional complexity into the software architecture and code.
This complexity can often be avoided by completely rearchitecting the software.
However, in practice the trade-off of (usually) slightly more complicated code is better than throwing everything away and constantly starting anew; and never finishing the software.

* Fundamental Software Architecture

** Application, Infrastructure and Interface Code

When looking at software systems, it is possible to categorize its code based on its purpose:
- Application ::
  Code that will do the actual business logic and trigger side-effects, i.e., the code deciding which side-effects shall be triggered.
  The Application code will make sure that a specific problem is solved for the user. A user can be a human, or a Platform that sits on-top.
- Infrastructure ::
  Code that is implementing logic necessary for correct and efficient execution of Application code.
- Interfaces ::
  Description of how the code layer are able to interact.

I.e., software can be described as:

[[./SoftwareAppAndInfra.drawio.svg]]

When viewing software in terms of Application, Infrastructure and Interfaces, the fundamental task of doing software architecture can be described as:
When to introduce an additional layer with interfaces, and who should own the interfaces?

*** Examples

** Dependency inversion

A conceptually lower level commonly wants to have access to and use the upper layer.
To prevent cyclic dependencies, it is now necessary to use dependency inversion:
if the lower level needs to implement an interface for custom code execution, the interface needs to owned by the upper layer.

For the upper layer to find implemented hooks, manual registration (dependency injection) can be implemented, however, frameworks providing more automatic dependency injection are very popular.
The dependency injection frameworks allow querying for implementations of a specific interface.

Because dependency inversion is very popular of allowing lower layers to provide custom logic, systems often feel like they basically only consist out of hooks that are calling other hooks that coll other hooks etc.
A good practice too keep an overview is that a hook should usually be used either for Platform or Application logic, but not both.
Note that the implementation might provide an additional hook; this hook can again be either for Platform or Application logic.
All interface definitions count as Platform code.

*** Example

Many frameworks provide a way of dependency injection.
One such group of frameworks are component frameworks:
these frameworks generally allow the registering of services implementing interfaces.
Component packages can be loaded, which will fill the registry of the component framework providing a way to instantiate services that implement a specific interface.

E.g., the Platform code can provide a "hook" interface that can be implementated by the Application code.
When loading the Application code into the component framework, the Platform is able to find the implementations by asking for implementers of its "hook" interface.

** Managing side effects

Software that has no side-effects is useless.
The side-effects are the end-all of software.
It therefore is important to identify and understand the side-effect of the software.

The general guideline is that side-effects shall happen as high as possible in the call stack of the respective Platform / Application layer.

*** Related: command pattern

It is possible to cheat and put the side-effects even higher in the call-stack: the command pattern can be used.
I.e., objects can be prepared (which can have arbitrarily deep call-stacks) that are then directly triggered by a layer further up.

While this can be a nice pattern for improving performance, I don't think that this particularly helps with understandability of code.

*** Example

Following this guideline will help with being able to program in a more (fully) functional way:
Because the side-effects happen already at the top, any kind of data processing and preparation of inputs for the side-effect can be implemented in a fully-functional way.

Fully-functional code has the advantage of being easier to document, understand and test.

** Rule of 7

Humans can generally hold about 7 things in their mind at the same time.
Translated into the software world, this means that we should ensure that code should not depend/interact with more then 7 other separate systems.
Fundamental software entities (e.g., standard library, or systems that are used all over the codebase) are not counted.
Additionally, a single "system" can also be a collection of similar working code; make sure that it is easy to see when something belongs to such a system, e.g., bundling them into a common namespace.

*** Examples

**** Architectural entities

When describing the building block view of a specific software, one starts with the whole system, there should now only be about 7 systems that together this system.
Each of those systems should at most consist of about about 7 systems again, etc.
(Excluding basic dependencies that are part of the base system upon which everything is built.)

**** Code

There should only be 7 systems that are injected via dependency injection in a given class.
(Not counting systems that are very fundamental and basically used everyhwere.)

If there are too many dependencies,
Facades can be introduced that bundle systems and provide a more easily useable system.

* Conclusion

These concept should be able to be mapped onto any software.
With these concepts in mind, the resulting software should already be pretty scalable in terms of complexity and people working on it.
Note that the whole process is often times iterative: i.e., only introduce platforms after discovering that they are needed.
Planning everything up-front is very hard to do. If the project is small: just start.
If the project is significant: prototype concepts and decide based on the experience with the prototype for good boundary layer between the Application and Platform.

* Appendix A Interfaces

#+BEGIN_COMMENT
Describe what an interface is in software.
It is not an OOP term!
It can basically appear in any kind of programming environment.
#+END_COMMENT

Software interfaces exist in various forms:
- files and file formats,
- (file/internet) sockets and the various protocols built on top of them
- standard input / output
- C-ABI linking
- various interface descriptions in the given programming language
- duck-typing in more dynamic programming languages
- language independent interface descriptions for use with inter-process communication (for example implemented via a socket)
- etc.

Note that basically any programming language, no matter the paradigmas they support, can be used to provide a generally useable interface.
However, specific programming environments are better with interfacing between each other.
E.g., a pure C++ programming environment where everything is always re-compiled can directly use C++ ABI via C++ header file descriptions, allowing to use all concepts of C++ for describing interfaces.
If different programming environments want to interface with each other, more generic or complicated interface formats need to be used,
often requiring large amounts of boilerplate and/or Platform code to make using it "feel good".

* Appendix B Application, Platform Examples

** Abstract product

* Appendix C Additional principles to remember and live by:

** KISS

Keep it simple, stupid.
This is harder to do than it sounds.
Counterintuitively, implementing a complex solution is often times a lot easier.
Don't have pride in building complex solutions, have pride in building simple (as possible) solutions for complex problems!

** SOLID

Whenever I think about the SOLID principles, I do find them surprisingly relevant.
I think it is worth while to also remember and live them.

The "I" even made it into my list.

** Interfaces should be easy to use and hard to misuse

/See title./

* Appendix Z just want to read more

Note that the listed resources do not necessarily relate to what is written here.
There is even a chance that they try to contradict some information of this document.
However, if you like reading about this topic, here are some more resources.

- Tiger beetle design
- Google SWEngineering https://abseil.io/resources/swe-book/html/toc.html
- https://stacktower.io dependency visualization
