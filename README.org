#+TITLE Fundamental Software Architecture
#+AUTHOR Marvin Dostal
#+LANGUAGE en_us

* Goal

This document aims to communicate the fundamentals of software architecture in a succinct but easy to understand way.

* (Optional) Introduction of the context

If you have already worked a lot with software, this document might seem unnecessary or obvious to you.
However, I do think it is important to express in concrete words what I have learned over the years with regards to what software architecture really means in practice.
I do not claim that this is the one valid way to look at software.
However, I do think it is a very useful view.

The topic of software architecture often-times feels like an object that whenever tried to be grabbed, it will just float away:
making it impossible to to clearly communicate.
Very long books exist that talk and talk about this topic.
However, they are too long as to keep all the information in the brain.

This document will try to describe only very few concepts that IMHO are already sufficient to understand how "good" software is usually structured.
"good" in the context of this document is primarily concerned with /understandability/ and /maintainability/.

** Why I don't think this document needs to go into details for "performance"

While performance is an important part of "good" software, it usually is already good enough by keeping things simple.
It can be true that a chosen architecture, which follows the details described here, can have horrible performance,
however, in my experience this can usually be solved by looking at the specific locations that slow everything down and optimizing them.

One principle to keep in mind to keep performance high is when processing data to process as much as possible in batches as this helps with:
- sharing computation results across the system
  - as opposed to calculating the same thing over and over for a slightly different context
- hardware access can be combined
  - as opposed to doing every hardware access sequentially
- if the data to be processed and the result memory are coherent memory blocks, CPU caches works optimally
  - as opposed to data and results being scattered all over the system requiring the CPU to stop and wait for cache-lines to be filled
- parallelization can be implemented to work on multiple elements of the batch in parallel
  - as opposed to doing everything sequentially
- etc.

Sometimes these performance improvements introduce additional complexity into the software architecture and code.
This complexity could have been avoided by completely rearchitecting the software.
However, in practice the trade-off of (hopefully) slightly more complicated code, but finishing a project, is better than throwing everything away and constantly starting anew.

* Fundamental Software Architecture

** The two kinds of code: Application and Infrastructure

When looking at most software systems, it is possible to categorize code based on its purpose:
- Application "What? And When?" ::
  Code that that will do the actual business logic and trigger side-effects, i.e., the code deciding which side-effects shall be triggered.
  The Application code will make sure that a specific problem is solved for the user. A user can be a human, or a Platform that sits on-top.
- Infrastructure "How?" ::
  Code doing boilerplate things necessary for correct and efficient execution of Application code.

Additionally, Interfaces connecting the code layers are necessary.

I.e., software can be described as:

[[./SoftwareAppAndInfra.drawio.svg]]

When viewing software in terms of Application, Infrastructure and Interfaces, the fundamental task of doing software architecture can be described as:
When to introduce an additional layer with interfaces, and who should own the interfaces?

*** Examples

** Dependency inversion

A conceptually lower level commonly wants to have access to and use the upper layer.
To prevent cyclic dependencies, it is now necessary to use dependency inversion:
if the lower level needs to implement an interface for custom code execution, the interface needs to owned by the upper layer.

For the upper layer to find implemented hooks, manual registration (dependency injection) can be implemented, however, frameworks providing more automatic dependency injection are very popular.
The dependency injection frameworks allow querying for implementations of a specific interface.

Because dependency inversion is very popular of allowing lower layers to provide custom logic, systems often feel like they basically only consist out of hooks that are calling other hooks that coll other hooks etc.
A good practice too keep an overview is that a hook should usually be used either for Platform or Application logic, but not both.
Note that the implementation might provide an additional hook; this hook can again be either for Platform or Application logic.
All interface definitions count as Platform code.

*** Example

Many frameworks provide a way of dependency injection.
One such group of frameworks are component frameworks:
these frameworks generally allow the registering of services implementing interfaces.
Component packages can be loaded, which will fill the registry of the component framework providing a way to instantiate services that implement a specific interface.

E.g., the Platform code can provide a "hook" interface that can be implementated by the Application code.
When loading the Application code into the component framework, the Platform is able to find the implementations by asking for implementers of its "hook" interface.

** Managing side effects

Software that has no side-effects is useless.
The side-effects are the end-all of software.
It therefore is important to identify and understand the side-effect of the software.

The general guideline is that side-effects shall happen as high as possible in the call stack of the respective Platform / Application layer.

*** Related: command pattern

It is possible to cheat and put the side-effects even higher in the call-stack: the command pattern can be used.
I.e., objects can be prepared (which can have arbitrarily deep call-stacks) that are then directly triggered by a layer further up.

While this can be a nice pattern for improving performance, I don't think that this particularly helps with understandability of code.

*** Example

Following this guideline will help with being able to program in a more (fully) functional way:
Because the side-effects happen already at the top, any kind of data processing and preparation of inputs for the side-effect can be implemented in a fully-functional way.

Fully-functional code has the advantage of being easier to document, understand and test.

** Rule of 7

Humans can generally hold about 7 things in their mind at the same time.
Translated into the software world, this means that we should ensure that code should not depend/interact with more then 7 other separate systems.
Fundamental software entities (e.g., standard library, or systems that are used all over the codebase) are not counted.
Additionally, a single "system" can also be a collection of similar working code; make sure that it is easy to see when something belongs to such a system, e.g., bundling them into a common namespace.

*** Examples

**** Architectural entities

When describing the building block view of a specific software, one starts with the whole system, there should now only be about 7 systems that together this system.
Each of those systems should at most consist of about about 7 systems again, etc.
(Excluding basic dependencies that are part of the base system upon which everything is built.)

**** Code

There should only be 7 systems that are injected via dependency injection in a given class.
(Not counting systems that are very fundamental and basically used everyhwere.)

If there are too many dependencies,
Facades can be introduced that bundle systems and provide a more easily useable system.

* Conclusion

These concept should be able to be mapped onto any software.
With these concepts in mind, the resulting software should already be pretty scalable in terms of complexity and people working on it.
Note that the whole process is often times iterative: i.e., only introduce platforms after discovering that they are needed.
Planning everything up-front is very hard to do. If the project is small: just start.
If the project is significant: prototype concepts and decide based on the experience with the prototype for good boundary layer between the Application and Platform.

* Appendix A Interfaces

#+BEGIN_COMMENT
Describe what an interface is in software.
It is not an OOP term!
It can basically appear in any kind of programming environment.
#+END_COMMENT

Software interfaces exist in various forms:
- files and file formats,
- (file/internet) sockets and the various protocols built on top of them
- standard input / output
- C-ABI linking
- various interface descriptions in the given programming language
- duck-typing in more dynamic programming languages
- language independent interface descriptions for use with inter-process communication (for example implemented via a socket)
- etc.

Note that basically any programming language, no matter the paradigmas they support, can be used to provide a generally useable interface.
However, specific programming environments are better with interfacing between each other.
E.g., a pure C++ programming environment where everything is always re-compiled can directly use C++ ABI via C++ header file descriptions, allowing to use all concepts of C++ for describing interfaces.
If different programming environments want to interface with each other, more generic or complicated interface formats need to be used,
often requiring large amounts of boilerplate and/or Platform code to make using it "feel good".

* Appendix B Application, Platform Examples

** Abstract product

* Appendix C Additional principles to remember and live by:

** KISS

Keep it simple, stupid.
This is harder to do than it sounds.
Counterintuitively, implementing a complex solution is often times a lot easier.
Don't have pride in building complex solutions, have pride in building simple (as possible) solutions for complex problems!

** SOLID

Whenever I think about the SOLID principles, I do find them surprisingly relevant.
I think it is worth while to also remember and live them.

The "I" even made it into my list.

** Interfaces should be easy to use and hard to misuse

/See title./

* Appendix Z just want to read more

Note that the listed resources do not necessarily relate to what is written here.
There is even a chance that they try to contradict some information of this document.
However, if you like reading about this topic, here are some more resources.

- Tiger beetle design
- Google SWEngineering https://abseil.io/resources/swe-book/html/toc.html
- https://stacktower.io dependency visualization
